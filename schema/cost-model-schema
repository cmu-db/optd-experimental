// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Table database {
  id integer PK
  created_time timestamp 
}

Table namespace_schema {
  id integer PK
  database_id integer
  name varchar
  created_time timestamp
}

Table table_metadata {
  id integer PK
  schema_id inintegert
  name varchar
  created_time timestamp
}

Table table_attribute {
  id integer PK // global index
  table_id integer
  name varchar
  compression_method char
  type integer // Data type of this attribute. Should we make another table to explain the type mapping?
  base_col_number integer // local index within the table
  is_not_null boolean // physical property
}

Table attribute_stats {
  id integer PK
  number_of_attributes integer // do we need it?
  data json // stores the related table id and attribute ids
  epoch_id integer
  name varchar
  created_time timestamp
  stats_type integer // Should we make another table to explain the type mapping?
  stats_value integer // Can we represent every stats value into integer?
}

Table event {
  epoch_id integer PK
  source_variant varchar
  create_timestamp timestamp
  data json
}

Table cost {
  id integer PK
  expr_id integer [ref: > physical_expression.id]
  epoch_id integer [ref: > event.epoch_id]
  cost integer
  valid boolean
}

Table index {
  id integer PK
  name varchar
  table_id integer [ref: > table_metadata.id]
  number_of_attributes integer
  is_unique boolean
  nulls_not_distinct boolean // Only valid for unique index, if true, then null value is equal, if false, null value is distinct
  is_primary boolean
  is_clustered boolean // If true, the table was last clustered on this index
  data json // Stores the attribute ids. The reason for not creating an additional junction table is the same as with the attribute_stats table.
}

Table trigger {
  id integer PK
  name varchar
  table_id integer [ref: > table_metadata.id]
  parent_trigger_id integer [ref: > trigger.id]
  function json
}

Ref: database.id < namespace_schema.database_id
Ref: namespace_schema.id < table_metadata.schema_id
Ref: table_metadata.id < table_attribute.table_id
Ref: attribute_stats.epoch_id > event.epoch_id


// Logical expressions and groups
Table logical_expression {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  fingerprint integer
  variant_tag integer
  data json
}

Table cascades_group {
  id integer [pk]
  latest_winner integer [ref: > physical_expression.id, null]
  in_progress boolean
  is_optimized boolean
}

// Physical expressions and properties
Table physical_expression {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  fingerprint integer
  variant_tag integer
  data json
}

Table physical_property {
  id integer [pk]
  physical_expression_id integer [ref: > physical_expression.id]
  variant_tag integer
  data json
}

// Junction tables
Table logical_group_junction {
  group_id integer [ref: > cascades_group.id]
  logical_expression_id integer [ref: > logical_expression.id]
}

Table physical_group_junction {
  group_id integer [ref: > cascades_group.id]
  physical_expression_id integer [ref: > physical_expression.id]
}

// Properties
Table logical_property {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  variant_tag integer
  data json
}

// Winners tracking
Table group_winner {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  physical_expression_id integer [ref: > physical_expression.id]
  cost integer
  epoch_id integer [ref: > event.epoch_id]
}


// Notes:
// - All columns are NOT NULL unless specified otherwise
// - fingerprint represents a hash of the actual data in the logical and physical expression tuple
// - Each new event inserted into events table has its own epoch_id
// - cascades_group.latest_winner is an optimization to avoid querying entire group_winner table
