// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

Table database {
  id int PK
  created_time timestamp 
}

Table namespace_schema {
  id int PK
  database_id int
  name varchar
  created_time timestamp
}

Table table_metadata {
  id int PK
  schema_id int
  name varchar
  created_time timestamp
}

Table table_attribute {
  id int PK // global index
  table_id int
  name varchar
  compression_method char
  type int // Data type of this attribute. Should we make another table to explain the type mapping?
  base_col_number int // local index within the table
  is_not_null bool // physical property
}

Table attribute_stats {
  id int PK
  number_of_attributes int // Do we need it?
  data json // Stores the related table id and attribute ids.
  // Currently, the reason why we don't make an extra conjuntion table is:
  // Let's assume in the stats_attr_mapping (the junction table) table:
  // Stats_id, attr_id
  // 1, 1
  // 2, 1
  // 2, 2

  // So let say we have 2 stats, the first one is a single-column stats, 
  // and the second one are multi-columns stats. So if we want to query 
  // the stats for column 1 (attribute 1), then it is hard to get it unless 
  // we have a field in the stats_table indicating the number of columns. 
  // But even with that field, what if we want to query the stats for 
  // column 1 and 2? I think we need join stats table and then join 
  // stats_attr_mapping table twice to get the result, and it sounds like 
  // too many joins.

  epoch_id int
  name varchar
  created_time timestamp
  stats_type int // Should we make another table to explain the type mapping?
  stats_value int // Can we represent every stats value into integer?
}

Table event {
  epoch_id int PK
  source_variant varchar
  create_timestamp timestamp
  data json
}

Table index {
  id int PK
  name varchar
  table_id int [ref: > table_metadata.id]
  number_of_attributes int
  is_unique bool
  nulls_not_distinct bool // Only valid for unique index, if true, then null value is equal, if false, null value is distinct
  is_primary bool
  is_clustered bool // If true, the table was last clustered on this index
  data json // Stores the related attribute ids. The reason for not creating an additional junction table is the same as with the attribute_stats table.
}

Table trigger {
  id int PK
  name varchar
  table_id int [ref: > table_metadata.id]
  parent_trigger_id int [ref: > trigger.id]
  function json
}

Ref: database.id < namespace_schema.database_id
Ref: namespace_schema.id < table_metadata.schema_id
Ref: table_metadata.id < table_attribute.table_id
Ref: attribute_stats.epoch_id > event.epoch_id


// Logical expressions and groups
Table logical_expression {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  fingerprint integer
  variant_tag integer
  data json
}

Table cascades_group {
  id integer [pk]
  latest_winner integer [ref: > physical_expression.id, null]
  in_progress boolean
  is_optimized boolean
}

// Physical expressions and properties
Table physical_expression {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  fingerprint integer
  variant_tag integer
  data json
}

Table physical_property {
  id integer [pk]
  physical_expression_id integer [ref: > physical_expression.id]
  variant_tag integer
  data json
}

// Junction tables
Table logical_group_junction {
  group_id integer [ref: > cascades_group.id]
  logical_expression_id integer [ref: > logical_expression.id]
}

Table physical_group_junction {
  group_id integer [ref: > cascades_group.id]
  physical_expression_id integer [ref: > physical_expression.id]
}

// Properties
Table logical_property {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  variant_tag integer
  data json
}

// Winners tracking
Table group_winner {
  id integer [pk]
  group_id integer [ref: > cascades_group.id]
  physical_expression_id integer [ref: > physical_expression.id]
  cost integer
  epoch_id integer [ref: > event.epoch_id]
}


// Notes:
// - All columns are NOT NULL unless specified otherwise
// - fingerprint represents a hash of the actual data in the logical and physical expression tuple
// - Each new event inserted into events table has its own epoch_id
// - cascades_group.latest_winner is an optimization to avoid querying entire group_winner table
